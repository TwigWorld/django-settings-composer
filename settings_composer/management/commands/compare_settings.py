import importlib
import os
import sys

from optparse import make_option

from django.core.management.base import BaseCommand, CommandError

from settings_composer import constants


COMMAND_OPTIONS = [
    (
        ['--module', '-m'],
        {
            'dest': 'module',
            'nargs': 1
        }
    ),
    (
        ['--site', '-s'],
        {
            'dest': 'site',
            'nargs': 1
        }
    ),
    (
        ['--env', '-e'],
        {
            'dest': 'env',
            'nargs': 1
        }
    ),
    (
        ['--switches', '-S'],
        {
            'dest': 'switches',
            'action': 'append'
        }
    ),
]


class Command(BaseCommand):
    help = (
        "Compare a conventional settings module with settings generated by "
        "Django Settings Composer. The command will look at the currently "
        "set environmental variables to determine which Settings Composer "
        "modules to load. Either pass in the name of a settings module, or "
        "pass in no arguments for the command to use DJANGO_SETTINGS_MODULE"
    )

    # For Django <= 1.7
    option_list = list(BaseCommand.option_list) + [
        make_option(*opt_args, **opt_kwargs)
        for opt_args, opt_kwargs in COMMAND_OPTIONS
    ]

    # For Django >= 1.8
    def add_arguments(self, parser):
        parser.add_argument(
            'source_module',
            help=(
                "The name of the settings module to compare against. Defaults "
                "to whatever DJANGO_SETTINGS_MODULE is set to."
            )
        )
        for opt_args, opt_kwargs in COMMAND_OPTIONS:
            parser.add_option(*opt_args, **opt_kwargs)

    def handle(self, source_module=None, **options):
        self.options = options
        self.load_source_module(source_module or os.environ.get('DJANGO_SETTINGS_MODULE'))
        self.load_composer_module()
        self.compare_settings_modules()
        while True:
            self.get_query()

    def load_source_module(self, module_name):
        try:
            self.original_settings = importlib.import_module(module_name)
            self.stdout.write(
                u"Loaded original settings module:\n    {module_name}\n".format(module_name=module_name)
            )
        except (ImportError, ValueError):
            raise CommandError(
                "Invalid module '{module_name}'\n"
                "You must either set the DJANGO_SETTINGS_MODULE environment "
                "variable or pass in a valid settings module to compare with".format(
                    module_name=module_name
                )
            )

    def load_composer_module(self):
        if self.options['module']:
            os.environ[constants.SETTINGS_MODULE_VARIABLE_NAME] = self.options['module']
        if self.options['site']:
            os.environ[constants.SITE_VARIABLE_NAME] = self.options['site']
        if self.options['env']:
            os.environ[constants.ENV_VARIABLE_NAME] = self.options['env']
        if self.options['switches']:
            os.environ[constants.SWITCHES_VARIABLE_NAME] = u','.join(self.options['switches'])
        self.composer_settings = importlib.import_module('settings_composer.settings')

    def compare_settings_modules(self):
        original_keys = [key for key in dir(self.original_settings) if key.isupper()]
        composer_keys = [
            key for key in dir(self.composer_settings)
            if (
                key.isupper()
                and not key == 'SETTINGS_COMPOSER_SOURCE'
            )
        ]

        missing_keys = set(original_keys) - set(composer_keys)
        new_keys = set(composer_keys) - set(original_keys)
        shared_keys = set(original_keys) - missing_keys

        self.stdout.write(u"Missing entries:\n    " + "\n    ".join(missing_keys))

        self.stdout.write(u"New entries:\n    " + u"\n    ".join(new_keys))

        changed_keys = []
        for key in shared_keys:
            original_value = getattr(self.original_settings, key)
            composer_value = getattr(self.composer_settings, key)
            if isinstance(original_value, tuple):
                original_value = list(original_value)
            if isinstance(composer_value, tuple):
                composer_value = list(composer_value)
            if original_value != composer_value:
                changed_keys.append(key)
        self.stdout.write(u"Changed entries:\n    " + u"\n    ".join(changed_keys))

    def get_query(self):
        self.stdout.write("Enter the name of a setting to query (Ctrl-D to exit):\n")
        try:
            setting_name = raw_input("> ")
            self.compare_setting(setting_name)
        except EOFError:
            sys.stdout.write("\n")
            sys.exit(1)

    def compare_setting(self, setting_name):
        if not setting_name.isupper() or (
            not hasattr(self.original_settings, setting_name) and
            not hasattr(self.composer_settings, setting_name)
        ):
            sys.stdout.write("'{setting_name}' is not a valid setting name to compare\n".format(setting_name=setting_name))
        original_value = getattr(self.original_settings, setting_name, '<NOT SET>')
        composer_value = getattr(self.composer_settings, setting_name, '<NOT_SET>')
        sys.stdout.write('\n\n----------ORIGINAL SETTING----------\n')
        sys.stdout.write(unicode(original_value))
        sys.stdout.write('\n\n\n----------COMPOSER SETTING----------\n')
        sys.stdout.write(unicode(composer_value))
        sys.stdout.write('\n\n\n----------COMPOSER SOURCE----------- \n')
        sys.stdout.write(', '.join(self.composer_settings.SETTINGS_COMPOSER_SOURCE.get(setting_name, [])))
        sys.stdout.write('\n\n\n')
